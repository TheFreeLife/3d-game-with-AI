<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <title>Three.js FPS - Ladder Climbing</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
      user-select: none;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      transform: translate(-50%, -50%);
    }

    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: #0f0;
    }

    #crosshair::before {
      top: 9px;
      left: 0;
      width: 20px;
      height: 2px;
    }

    #crosshair::after {
      top: 0;
      left: 9px;
      width: 2px;
      height: 20px;
    }

    #hp-bar-container {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 300px;
      height: 30px;
      background-color: rgba(0, 0, 0, 0.5);
      border: 2px solid #fff;
      border-radius: 4px;
    }

    #hp-bar {
      width: 100%;
      height: 100%;
      background-color: #ff0000;
      /* 빨간색 체력바 */
      transition: width 0.2s ease-out;
    }

    #ammo-display {
      position: absolute;
      bottom: 20px;
      right: 20px;
      font-size: 32px;
      font-weight: bold;
      color: #ffffff;
      text-shadow: 2px 2px 2px #000;
      font-family: 'Courier New', Courier, monospace;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 10;
      pointer-events: auto;
    }

    #instructions {
      font-size: 36px;
      cursor: pointer;
    }

    #controls-info {
      margin-top: 20px;
      font-size: 16px;
      text-align: center;
    }
  </style>
</head>

<body>
  <div id="ui-layer">
    <div id="hp-bar-container">
      <div id="hp-bar"></div>
    </div>
    <div id="ammo-display">30 / 30</div>
    <div id="crosshair"></div>
  </div>

  <div id="blocker">
    <div id="instructions">클릭하여 시작</div>
    <div id="controls-info">
      W, A, S, D : 이동 | SPACE : 점프 | TAB : 시점 전환<br>
      <span style="color: cyan;">사다리에 붙어서 W를 누르면 올라갑니다.</span><br>
      (사다리는 어두운 회색으로 건물 벽에 붙어있습니다)
    </div>
  </div>

  <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import * as CANNON from 'cannon-es';

    // ==========================================
    // 1. Weapon, PhysicsManager, Zombie, EnemyManager
    // (이전 코드와 동일하므로 압축 유지)
    // ==========================================
    class Weapon {
      constructor(scene) {
        this.scene = scene;
        this.fireRate = 0.1; this.nextFireTime = 0; this.isFiring = false;
        this.recoilAngle = 0; this.currentRecoilSim = 0; this.flashDuration = 0.08; this.flashTimer = 0;

        // [추가] 탄약 시스템
        this.maxAmmo = 30;
        this.currentAmmo = 30;
        this.isReloading = false;
        this.ammoDisplay = document.getElementById('ammo-display');

        this.raycaster = new THREE.Raycaster(); this.raycaster.far = 200;
        this.mesh = this._createAK47();
        this.updateAmmoUI();
      }
      _createAK47() {
        const gunGroup = new THREE.Group();
        const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const metalMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.12, 0.6), metalMat);
        const stock = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.14, 0.35), woodMat);
        stock.position.set(0, -0.05, 0.45);
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.65, 8), metalMat);
        barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.08, -0.5);
        const mag = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.35, 0.15), metalMat);
        mag.position.set(0, -0.25, -0.1); mag.rotation.x = 0.4;
        gunGroup.add(body, stock, barrel, mag);
        const flashGeo = new THREE.DodecahedronGeometry(0.2, 0);
        const flashMat = new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, opacity: 0.9, depthWrite: false });
        this.flashMesh = new THREE.Mesh(flashGeo, flashMat);
        this.flashMesh.position.set(0, 0.08, -1.0); this.flashMesh.visible = false;
        gunGroup.add(this.flashMesh);
        this.flashLight = new THREE.PointLight(0xffaa00, 0, 15);
        this.flashLight.position.set(0, 0.1, -1.1);
        gunGroup.add(this.flashLight);
        return gunGroup;
      }
      startFiring() {
        if (!this.isReloading && this.currentAmmo > 0) this.isFiring = true;
        else if (this.currentAmmo <= 0) this.reload(); // 총알 없으면 자동 재장전 시도 혹은 클릭 시 재장전
      }
      stopFiring() { this.isFiring = false; }

      reload() {
        if (this.isReloading || this.currentAmmo === this.maxAmmo) return;
        this.isReloading = true;
        this.isFiring = false; // 재장전 중 사격 중지
        this.updateAmmoUI();

        // 2초 후 재장전 완료
        setTimeout(() => {
          this.currentAmmo = this.maxAmmo;
          this.isReloading = false;
          this.updateAmmoUI();
        }, 2000);
      }

      updateAmmoUI() {
        if (this.ammoDisplay) {
          if (this.isReloading) {
            this.ammoDisplay.innerText = "RELOADING...";
            this.ammoDisplay.style.color = "yellow";
          } else {
            this.ammoDisplay.innerText = `${this.currentAmmo} / ${this.maxAmmo}`;
            this.ammoDisplay.style.color = this.currentAmmo <= 5 ? "red" : "white";
          }
        }
      }

      update(delta, time, targetObjects, pivot) {
        if (this.isFiring && time >= this.nextFireTime) {
          if (this.currentAmmo > 0 && !this.isReloading) {
            this.fire(targetObjects, pivot);
            this.nextFireTime = time + this.fireRate;
          } else {
            this.isFiring = false;
          }
        }
        if (this.flashTimer > 0) { this.flashTimer -= delta; if (this.flashTimer <= 0) { this.flashMesh.visible = false; this.flashLight.intensity = 0; } }
        pivot.rotation.x -= this.recoilAngle;
        this.currentRecoilSim = THREE.MathUtils.lerp(this.currentRecoilSim, 0, delta * 10);
        this.recoilAngle = this.currentRecoilSim;
        pivot.rotation.x += this.recoilAngle;
        if (this.targetPos) {
          this.mesh.position.z = THREE.MathUtils.lerp(this.mesh.position.z, this.targetPos.z, delta * 15);
          this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, this.targetRot.x, delta * 15);
        }
      }
      fire(targetObjects, pivot) {
        this.currentAmmo--;
        this.updateAmmoUI();
        this.currentRecoilSim += 0.02; this.mesh.position.z += 0.15; this.mesh.rotation.x += 0.1;
        this.flashMesh.visible = true; this.flashMesh.rotation.z = Math.random() * Math.PI;
        this.flashMesh.scale.setScalar(0.8 + Math.random() * 0.5); this.flashLight.intensity = 3.0; this.flashTimer = this.flashDuration;
        const direction = new THREE.Vector3(0, 0, -1); direction.applyQuaternion(pivot.quaternion);
        this.raycaster.set(pivot.position, direction);
        const intersects = this.raycaster.intersectObjects(targetObjects, true);
        if (intersects.length > 0) {
          const hit = intersects[0];
          let target = hit.object;
          while (target) {
            if (target.userData && target.userData.isEnemy) { target.userData.entity.takeDamage(); this.createBloodEffect(hit.point, hit.face.normal); return; }
            target = target.parent;
          }
          this.createBulletHole(hit.point, hit.face.normal);
        }
      }
      createBulletHole(position, normal) {
        const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.05); const material = new THREE.MeshBasicMaterial({ color: 0xff2200 });
        const decal = new THREE.Mesh(geometry, material); decal.position.copy(position); decal.lookAt(position.clone().add(normal)); decal.position.add(normal.clone().multiplyScalar(0.01));
        this.scene.add(decal); setTimeout(() => { this.scene.remove(decal); geometry.dispose(); material.dispose(); }, 3000);
      }
      createBloodEffect(position, normal) {
        for (let i = 0; i < 5; i++) {
          const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1); const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
          const part = new THREE.Mesh(geometry, material); part.position.copy(position);
          part.position.x += (Math.random() - 0.5) * 0.5; part.position.y += (Math.random() - 0.5) * 0.5; part.position.z += (Math.random() - 0.5) * 0.5;
          this.scene.add(part); setTimeout(() => { this.scene.remove(part); geometry.dispose(); material.dispose(); }, 500);
        }
      }
      setTransformTarget(pos, rot) { this.targetPos = pos.clone(); this.targetRot = rot.clone(); this.mesh.position.copy(this.targetPos); this.mesh.rotation.copy(this.targetRot); }
    }

    class Zombie {
      constructor(game, startPosition) {
        this.game = game; this.health = 5; this.isDead = false; this.speed = 8 + Math.random() * 4;

        // 피격 모션 변수
        this.isHit = false;
        this.hitTimer = 0;

        this.mesh = this._createMesh(); this.mesh.position.copy(startPosition); this.game.scene.add(this.mesh);
        this.body = new CANNON.Body({ mass: 40, position: new CANNON.Vec3(startPosition.x, startPosition.y, startPosition.z), shape: new CANNON.Sphere(1.0), material: game.physics.defaultMaterial, fixedRotation: true, linearDamping: 0.9 });
        this.game.physics.world.addBody(this.body);
      }
      _createMesh() {
        const group = new THREE.Group();
        const skinMat = new THREE.MeshStandardMaterial({ color: 0x556b2f, roughness: 0.8 });
        const clothesMat = new THREE.MeshStandardMaterial({ color: 0x3d3d3d, roughness: 0.9 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.4, 0.6), clothesMat); body.position.y = 0.7; body.castShadow = true;
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), skinMat); head.position.y = 1.7; head.castShadow = true;

        const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.3), skinMat); leftArm.position.set(-0.65, 1.2, 0.4); leftArm.rotation.x = -Math.PI / 2;
        const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.3), skinMat); rightArm.position.set(0.65, 1.2, 0.4); rightArm.rotation.x = -Math.PI / 2;

        // 팔 참조 저장
        this.leftArm = leftArm;
        this.rightArm = rightArm;

        group.add(body, head, leftArm, rightArm);
        group.traverse((child) => { if (child.isMesh) { child.userData.isEnemy = true; child.userData.entity = this; } });
        return group;
      }
      takeDamage() {
        if (this.isDead) return;
        this.health--;

        // 피격 모션 시작
        this.isHit = true;
        this.hitTimer = 0;

        this.mesh.children.forEach(child => { if (child.material) { const oldColor = child.material.color.getHex(); child.material.color.setHex(0xff0000); setTimeout(() => { if (!this.isDead && child.material) child.material.color.setHex(oldColor); }, 100); } });
        if (this.health <= 0) this.die(); else this.body.velocity.y += 5;
      }
      die() { this.isDead = true; this.mesh.rotation.x = -Math.PI / 2; this.mesh.position.y -= 0.5; this.game.physics.world.removeBody(this.body); }
      update(delta, playerPos) {
        if (this.isDead) return;
        this.mesh.position.copy(this.body.position); this.mesh.position.y -= 1.0;
        this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);
        const direction = new THREE.Vector3(playerPos.x - this.body.position.x, 0, playerPos.z - this.body.position.z).normalize();
        this.body.velocity.x = direction.x * this.speed; this.body.velocity.z = direction.z * this.speed;

        // 피격 모션 업데이트 (팔 들썩이기)
        if (this.isHit) {
          this.hitTimer += delta;
          const duration = 0.3; // 0.3초 동안 모션
          if (this.hitTimer < duration) {
            // 사인 파형으로 팔을 -90도(기본)에서 위로(-150도 정도) 들었다가 내림
            // 0 ~ 1 -> 0 ~ PI
            const angle = Math.sin((this.hitTimer / duration) * Math.PI) * 1.0;
            this.leftArm.rotation.x = -Math.PI / 2 - angle;
            this.rightArm.rotation.x = -Math.PI / 2 - angle;
          } else {
            this.isHit = false;
            this.leftArm.rotation.x = -Math.PI / 2;
            this.rightArm.rotation.x = -Math.PI / 2;
          }
        }
      }
    }

    class EnemyManager {
      constructor(game) { this.game = game; this.zombies = []; this.maxZombies = 10; this.spawnTimer = 0; this.spawnInterval = 2.0; }
      update(delta, playerPos) {
        for (let i = this.zombies.length - 1; i >= 0; i--) {
          const zombie = this.zombies[i]; zombie.update(delta, playerPos);
          if (zombie.isDead) { if (!zombie.deathTimer) zombie.deathTimer = 0; zombie.deathTimer += delta; if (zombie.deathTimer > 2.0) { this.game.scene.remove(zombie.mesh); this.zombies.splice(i, 1); } }
          else {
            // 플레이어 공격 (거리 체크 - XZ 평면 + 높이 체크)
            const dx = zombie.mesh.position.x - playerPos.x;
            const dz = zombie.mesh.position.z - playerPos.z;
            const distSq = dx * dx + dz * dz;

            // 높이 차이 (대략적인 범위)
            // playerPos는 body 중심, zombie.mesh는 보정된 위치이므로 약간의 오차 허용
            const dy = Math.abs(zombie.mesh.position.y - playerPos.y);

            // 사거리 2.5m (제곱값 6.25), 높이차 2.5m 이내
            if (distSq < 6.25 && dy < 2.5) {
              // 간단한 쿨타임 로직
              if (!zombie.lastAttackTime) zombie.lastAttackTime = 0;
              const now = performance.now();
              if (now - zombie.lastAttackTime > 1000) { // 1초마다 공격
                if (this.game.player) this.game.player.takeDamage(10);
                zombie.lastAttackTime = now;
              }
            }
          }
        }
        this.spawnTimer += delta;
        if (this.spawnTimer > this.spawnInterval) { this.spawnTimer = 0; if (this.zombies.length < this.maxZombies) this.spawnZombie(playerPos); }
      }
      spawnZombie(playerPos) {
        const angle = Math.random() * Math.PI * 2; const distance = 20 + Math.random() * 20;
        const x = playerPos.x + Math.cos(angle) * distance; const z = playerPos.z + Math.sin(angle) * distance;
        this.zombies.push(new Zombie(this.game, new THREE.Vector3(x, 10, z)));
      }
      getMeshList() { return this.zombies.map(z => z.mesh); }
    }

    class PhysicsManager {
      constructor() {
        this.world = new CANNON.World(); this.world.gravity.set(0, -50, 0);
        this.world.broadphase = new CANNON.NaiveBroadphase(); this.defaultMaterial = new CANNON.Material('default');
        this.world.addContactMaterial(new CANNON.ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.0, restitution: 0.0 }));
      }
      update(delta) { this.world.step(1 / 60, delta, 3); }
    }

    // ==========================================
    // 2. Player Class (사다리 타기 로직 추가)
    // ==========================================
    class Player {
      constructor(game, domElement) {
        this.game = game; this.camera = game.camera; this.scene = game.scene;
        this.pivot = new THREE.Object3D(); this.pivot.position.y = 1.6; this.scene.add(this.pivot); this.pivot.add(this.camera);
        this.controls = new PointerLockControls(this.pivot, domElement);
        this.input = { forward: false, backward: false, left: false, right: false };
        this.canJump = false; this.isThirdPerson = false;

        this.isOnLadder = false;

        // [추가] 달리기 관련 변수
        this.isSprinting = false;       // 현재 달리기 중인지
        this.lastWKeyPressTime = 0;     // 마지막으로 W를 누른 시간
        this.walkSpeed = 25;            // 걷는 속도
        this.runSpeed = 50;             // 달리는 속도 (2배)

        // [추가] 체력 관련 변수
        this.maxHealth = 100;
        this.health = this.maxHealth;
        this.hpBar = document.getElementById('hp-bar');
        this.isDead = false;

        this.weapon = new Weapon(game.scene);
        this.playerMesh = this._createPlayerMesh(); this.scene.add(this.playerMesh);

        const radius = 1.3;
        this.shape = new CANNON.Sphere(radius);

        // [중요] 이전 질문에서 요청한 빠른 낙하 적용 (linearDamping: 0.01)
        this.body = new CANNON.Body({ mass: 50, position: new CANNON.Vec3(0, 30, 0), shape: this.shape, material: game.physics.defaultMaterial, fixedRotation: true, linearDamping: 0.01 });
        game.physics.world.addBody(this.body);

        const contactNormal = new CANNON.Vec3(); const upAxis = new CANNON.Vec3(0, 1, 0);
        this.body.addEventListener('collide', (e) => {
          const contact = e.contact;
          if (contact.bi.id === this.body.id) contact.ni.negate(contactNormal); else contactNormal.copy(contact.ni);
          if (contactNormal.dot(upAxis) > 0.5) this.canJump = true;
        });
        this._setFirstPersonView(); this._addEventListeners();
      }

      _createPlayerMesh() {
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 0.8), new THREE.MeshStandardMaterial({ color: 0x0055ff, roughness: 0.5 })); body.position.y = 0.9; body.castShadow = true;
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.5 })); head.position.y = 2.1; head.castShadow = true;
        const eyes = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.1), new THREE.MeshStandardMaterial({ color: 0x333333 })); eyes.position.set(0, 2.15, -0.36);
        group.add(body, head, eyes); return group;
      }

      _addEventListeners() {
        const onKeyDown = (e) => {
          switch (e.code) {
            case 'KeyW':
              // [핵심 수정] 키를 꾹 누르고 있을 때 발생하는 자동 반복 신호면 무시
              if (e.repeat) return;

              // 실제 물리적으로 키를 눌렀을 때만 실행됨
              const now = performance.now();
              if (now - this.lastWKeyPressTime < 250) {
                // 0.25초 안에 다시 눌렀다면 달리기 모드 ON
                this.isSprinting = true;
              }
              this.lastWKeyPressTime = now;

              this.input.forward = true;
              break;

            case 'KeyA': this.input.left = true; break;
            case 'KeyS': this.input.backward = true; break;
            case 'KeyD': this.input.right = true; break;
            case 'KeyR': this.weapon.reload(); break; // [추가] 재장전 키
            case 'Space': this.jump(); break;
            case 'Tab': e.preventDefault(); this.toggleView(); break;
          }
        };

        const onKeyUp = (e) => {
          switch (e.code) {
            case 'KeyW':
              this.input.forward = false;
              this.isSprinting = false; // 키를 떼면 달리기 즉시 해제
              break;
            case 'KeyA': this.input.left = false; break;
            case 'KeyS': this.input.backward = false; break;
            case 'KeyD': this.input.right = false; break;
          }
        };

        const onMouseDown = (e) => { if (this.controls.isLocked && e.button === 0) this.weapon.startFiring(); };
        const onMouseUp = (e) => { if (e.button === 0) this.weapon.stopFiring(); };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
      }

      toggleView() { this.isThirdPerson = !this.isThirdPerson; if (this.isThirdPerson) this._setThirdPersonView(); else this._setFirstPersonView(); }
      _setFirstPersonView() { this.playerMesh.visible = false; this.camera.position.set(0, 0, 0); this.pivot.add(this.weapon.mesh); this.weapon.setTransformTarget(new THREE.Vector3(0.45, -0.4, -0.7), new THREE.Euler(0, 0, 0)); }
      _setThirdPersonView() { this.playerMesh.visible = true; this.camera.position.set(0, 0.5, 4.0); this.playerMesh.add(this.weapon.mesh); this.weapon.setTransformTarget(new THREE.Vector3(0.6, 1.2, -0.5), new THREE.Euler(0, 0, 0)); }

      jump() {
        if (this.isOnLadder) {
          this.body.velocity.y = 10;
          this.body.velocity.z += 10;
        } else if (this.canJump) {
          this.body.velocity.y = Math.sqrt(2 * 50 * 7.0);
          this.canJump = false;
        }
      }

      checkLadderInteraction(ladders) {
        this.isOnLadder = false;
        const p = this.body.position;
        for (let ladder of ladders) {
          const inX = p.x >= ladder.minX - 0.5 && p.x <= ladder.maxX + 0.5;
          const inZ = p.z >= ladder.minZ - 0.5 && p.z <= ladder.maxZ + 0.5;
          const inY = p.y >= ladder.minY && p.y <= ladder.maxY + 1.0;

          if (inX && inZ && inY) {
            this.isOnLadder = true;
            break;
          }
        }
      }

      update(delta, time, levelMeshes, enemyMeshes, ladderData) {
        if (!this.controls.isLocked) return;

        this.checkLadderInteraction(ladderData);

        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        euler.setFromQuaternion(this.pivot.quaternion);
        const yaw = euler.y;

        if (this.isOnLadder) {
          this.body.velocity.y = 0;
          const climbSpeed = 10;
          if (this.input.forward) this.body.velocity.y = climbSpeed;
          if (this.input.backward) this.body.velocity.y = -climbSpeed;
          this.body.velocity.x *= 0.5;
          this.body.velocity.z *= 0.5;
          this.canJump = true;
        } else {
          const inputVector = new CANNON.Vec3(0, 0, 0);

          // [수정] 현재 상태에 따라 속도 결정
          const currentSpeed = this.isSprinting ? this.runSpeed : this.walkSpeed;

          if (this.input.forward) inputVector.z -= currentSpeed;
          if (this.input.backward) inputVector.z += currentSpeed;
          if (this.input.left) inputVector.x -= currentSpeed;
          if (this.input.right) inputVector.x += currentSpeed;

          const quaternion = new CANNON.Quaternion();
          quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), yaw);
          const velocityVector = quaternion.vmult(inputVector);
          this.body.velocity.x = velocityVector.x;
          this.body.velocity.z = velocityVector.z;
        }

        this.pivot.position.copy(this.body.position); this.pivot.position.y += 0.8;
        this.playerMesh.position.copy(this.body.position); this.playerMesh.position.y -= 1.3;
        this.playerMesh.rotation.y = yaw;

        const allTargets = levelMeshes.concat(enemyMeshes);
        this.weapon.update(delta, time, allTargets, this.pivot);
      }

      takeDamage(amount) {
        if (this.isDead) return;
        this.health -= amount;
        if (this.health < 0) this.health = 0;

        this.updateHealthUI();

        if (this.health <= 0) {
          this.isDead = true;
          alert('Game Over');
          location.reload();
        }
      }

      updateHealthUI() {
        if (this.hpBar) {
          const percentage = (this.health / this.maxHealth) * 100;
          this.hpBar.style.width = `${percentage}%`;
        }
      }
    }

    // ==========================================
    // 3. Level Class (사다리 생성 추가)
    // ==========================================
    class Level {
      constructor(game) {
        this.game = game;
        this.meshes = [];
        this.ladders = []; // 사다리 데이터 저장 (충돌 검사용)
        this._initLights();
        this._initCity();
      }



      _initLights() {
        // 아침 분위기 조명
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        this.game.scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xfff0dd, 2.0); // 따뜻한 아침 햇살
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -100; dirLight.shadow.camera.right = 100; dirLight.shadow.camera.top = 100; dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        this.game.scene.add(dirLight);
      }
      createObject(mesh, body) { this.game.scene.add(mesh); this.game.physics.world.addBody(body); this.meshes.push(mesh); }
      _initCity() {
        // 1. 바닥을 아스팔트 도로로 설정
        const groundGeo = new THREE.PlaneGeometry(1000, 1000);
        const groundMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a, // 진한 아스팔트 색
          roughness: 0.9
        });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        this.game.scene.add(groundMesh);
        this.meshes.push(groundMesh);

        // 물리 바닥
        const groundBody = new CANNON.Body({ mass: 0, material: this.game.physics.defaultMaterial });
        groundBody.addShape(new CANNON.Plane());
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        this.game.physics.world.addBody(groundBody);

        const blockSize = 30; // 격자 크기
        const streetWidth = 10; // 도로 폭
        const sidewalkSize = blockSize - streetWidth; // 보도블럭 크기 (20)
        const sidewalkHeight = 0.4; // 보도블럭 높이
        const gridSize = 10;

        const buildingColors = [0x888888, 0x5a6a7a, 0x4c5e70, 0x666666, 0x3a4550];

        // 보도블럭 재질 (콘크리트 느낌 + 테두리를 위한 약간의 밝은 톤)
        const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.8 });

        for (let x = -gridSize; x <= gridSize; x++) {
          for (let z = -gridSize; z <= gridSize; z++) {
            // 원점은 비워둠 (시작 지점)
            if (x === 0 && z === 0) continue;

            const posX = x * blockSize;
            const posZ = z * blockSize;

            // 2. 보도블럭(Sidewalk) 생성 - 살짝 튀어나오게
            const swGeo = new THREE.BoxGeometry(sidewalkSize, sidewalkHeight, sidewalkSize);
            const swMesh = new THREE.Mesh(swGeo, sidewalkMat);
            swMesh.position.set(posX, sidewalkHeight / 2, posZ);
            swMesh.receiveShadow = true;
            swMesh.castShadow = true;
            this.game.scene.add(swMesh);
            this.meshes.push(swMesh);

            // 보도블럭 물리 바디
            const swBody = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(posX, sidewalkHeight / 2, posZ), material: this.game.physics.defaultMaterial });
            swBody.addShape(new CANNON.Box(new CANNON.Vec3(sidewalkSize / 2, sidewalkHeight / 2, sidewalkSize / 2)));
            this.game.physics.world.addBody(swBody);


            // 3. 건물 생성 (보도블럭 위에)
            if (Math.random() < 0.3) continue; // 30% 확률로 빈 터 (공원이나 주차장 느낌이 됨)

            const isSkyscraper = Math.random() > 0.7;
            // [수정] 20% 확률로 들어갈 수 있는 건물 생성
            const isEnterable = Math.random() < 0.2;

            let width, depth, height;

            // 건물 크기는 보도블럭보다 작아야 함
            const maxBldgSize = sidewalkSize - 2;

            if (isSkyscraper) {
              width = Math.random() * (maxBldgSize - 10) + 10;
              depth = Math.random() * (maxBldgSize - 10) + 10;
              height = Math.random() * 60 + 40;
            } else {
              width = Math.random() * (maxBldgSize - 10) + 10;
              depth = Math.random() * (maxBldgSize - 10) + 10;
              height = Math.random() * 15 + 10;
            }

            // 높이: 보도블럭 높이
            const bldgY = sidewalkHeight;

            if (isEnterable && width > 10) {
              this._createEnterableBuilding(posX, posZ, width, depth, height, bldgY, buildingColors);
              // 내부 건물에는 사다리 생성 안함 (혹은 내부에 만들 수도 있지만 생략)
            } else {
              // 일반 건물 (통짜 박스)
              const geometry = new THREE.BoxGeometry(width, height, depth);
              const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
              const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.1 });
              const mesh = new THREE.Mesh(geometry, material);
              mesh.castShadow = true; mesh.receiveShadow = true;

              // 중심점 보정: BoxGeometry는 중심이 (0,0,0)이므로 y위치를 (높이/2 + 시작높이)로 잡아야 함
              mesh.position.set(posX, bldgY + height / 2, posZ);

              const body = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(posX, bldgY + height / 2, posZ), material: this.game.physics.defaultMaterial });
              body.addShape(new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2)));
              this.createObject(mesh, body);

              // [사다리 생성] - 일반 건물만
              if (Math.random() < 0.4) {
                this._createLadder(posX, posZ, width, depth, height, sidewalkHeight);
              }
            }
          }
        }
      }

      _createEnterableBuilding(x, z, w, d, h, y, colors) {
        const thickness = 1.0;
        const color = colors[Math.floor(Math.random() * colors.length)];
        const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.1, side: THREE.DoubleSide });

        const group = new THREE.Group();
        group.position.set(x, y, z);
        this.game.scene.add(group);

        // 물리 바디 (복합 형태)
        const body = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(x, y, z), material: this.game.physics.defaultMaterial });

        // Helper to add wall
        const addWall = (ww, wh, wd, px, py, pz) => {
          const geo = new THREE.BoxGeometry(ww, wh, wd);
          const mesh = new THREE.Mesh(geo, material);
          mesh.position.set(px, py, pz);
          mesh.castShadow = true; mesh.receiveShadow = true;
          group.add(mesh);
          this.meshes.push(mesh);

          body.addShape(new CANNON.Box(new CANNON.Vec3(ww / 2, wh / 2, wd / 2)), new CANNON.Vec3(px, py, pz));
        };

        // 1. 바닥 (Floor)
        // addWall(w, thickness, d, 0, thickness/2, 0); // 바닥은 이미 보도블럭이 있음

        // 2. 천장 (Ceiling)
        addWall(w, thickness, d, 0, h - thickness / 2, 0);

        // 3. 뒷벽 (Back) -Z
        addWall(w, h, thickness, 0, h / 2, -d / 2 + thickness / 2);

        // 4. 왼쪽벽 (Left) -X
        addWall(thickness, h, d, -w / 2 + thickness / 2, h / 2, 0);

        // 5. 오른쪽벽 (Right) +X
        addWall(thickness, h, d, w / 2 - thickness / 2, h / 2, 0);

        // 6. 앞벽 (Front) +Z -> 문(Door) 구멍 뚫기
        // 문 크기: 폭 6, 높이 5
        const doorW = 6;
        const doorH = 5;
        const wallW = (w - doorW) / 2; // 문 좌우 벽 너비

        // 앞벽 왼쪽
        addWall(wallW, h, thickness, -w / 2 + wallW / 2, h / 2, d / 2 - thickness / 2);
        // 앞벽 오른쪽
        addWall(wallW, h, thickness, w / 2 - wallW / 2, h / 2, d / 2 - thickness / 2);
        // 앞벽 위 (문 위쪽 헤더)
        const headerH = h - doorH;
        addWall(doorW, headerH, thickness, 0, doorH + headerH / 2, d / 2 - thickness / 2);

        this.game.physics.world.addBody(body);

        // 내부 조명 추가 (전략적 요충지 느낌)
        const bulb = new THREE.PointLight(0xffaa00, 1, 20);
        bulb.position.set(0, 4, 0);
        group.add(bulb);
      }

      _createLadder(bx, bz, bw, bd, bh, groundY = 0) {
        // 건물 4면 중 한 곳 랜덤 선택
        // 0: +Z (Front), 1: -Z (Back), 2: +X (Right), 3: -X (Left)
        const side = Math.floor(Math.random() * 4);

        const ladderWidth = 2.0;
        const ladderDepth = 0.5;
        let lx = bx, lz = bz;
        let rotationY = 0;

        // 사다리 위치 계산 (건물 표면에 붙임)
        const offset = 0.6; // 벽에서 살짝 띄움
        if (side === 0) { lz += bd / 2 + offset; rotationY = 0; }
        else if (side === 1) { lz -= bd / 2 + offset; rotationY = Math.PI; }
        else if (side === 2) { lx += bw / 2 + offset; rotationY = Math.PI / 2; }
        else if (side === 3) { lx -= bw / 2 + offset; rotationY = -Math.PI / 2; }

        // 1. 사다리 비주얼 생성 (단순하게 긴 박스 2개와 발판들)
        const ladderGroup = new THREE.Group();
        const railMat = new THREE.MeshStandardMaterial({ color: 0x222222 }); // 진한 회색

        // 세로 기둥 (Rails)
        const railGeo = new THREE.BoxGeometry(0.2, bh, 0.2);
        const leftRail = new THREE.Mesh(railGeo, railMat);
        leftRail.position.set(-ladderWidth / 2, bh / 2, 0);
        const rightRail = new THREE.Mesh(railGeo, railMat);
        rightRail.position.set(ladderWidth / 2, bh / 2, 0);

        // 가로 발판 (Rungs)
        const rungGeo = new THREE.BoxGeometry(ladderWidth, 0.1, 0.1);
        const rungCount = Math.floor(bh / 1.0); // 1미터 간격
        for (let i = 0; i < rungCount; i++) {
          const rung = new THREE.Mesh(rungGeo, railMat);
          rung.position.set(0, i * 1.0 + 0.5, 0);
          ladderGroup.add(rung);
        }

        ladderGroup.add(leftRail, rightRail);
        // 사다리는 보도블럭 위(groundY)에서 시작
        ladderGroup.position.set(lx, groundY, lz);
        ladderGroup.rotation.y = rotationY;
        this.game.scene.add(ladderGroup);
        // 사다리 메쉬도 총알 충돌체에 포함 (원하면)
        this.meshes.push(leftRail, rightRail); // 간단히 레일만 추가

        // 2. 사다리 데이터 저장 (충돌 감지용 AABB)
        // 회전에 따라 min/max 계산이 다르므로 간단히 중심점과 크기로 계산
        const hitBoxSize = 1.0; // 사다리 감지 두께

        let minX, maxX, minZ, maxZ;

        if (side === 0 || side === 1) { // Z축 방향 면에 붙음 -> X축으로 넓음
          minX = lx - ladderWidth / 2;
          maxX = lx + ladderWidth / 2;
          minZ = lz - hitBoxSize;
          maxZ = lz + hitBoxSize;
        } else { // X축 방향 면에 붙음 -> Z축으로 넓음
          minX = lx - hitBoxSize;
          maxX = lx + hitBoxSize;
          minZ = lz - ladderWidth / 2;
          maxZ = lz + ladderWidth / 2;
        }

        this.ladders.push({
          minX: minX, maxX: maxX,
          minZ: minZ, maxZ: maxZ,
          minY: groundY, maxY: groundY + bh // 바닥부터 건물 꼭대기까지
        });
      }
    }

    class Game {
      constructor() { this.init(); }
      init() {
        this.scene = new THREE.Scene();
        // 아침 하늘색 (SkyBlue)
        const skyColor = 0x87CEEB;
        this.scene.background = new THREE.Color(skyColor);
        this.scene.fog = new THREE.Fog(skyColor, 50, 300);
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(this.renderer.domElement);

        this.physics = new PhysicsManager();
        this.level = new Level(this);
        this.enemyManager = new EnemyManager(this);
        this.player = new Player(this, document.body);
        this._setupUI();
        this.clock = new THREE.Clock();
        window.addEventListener('resize', () => this.onWindowResize());
        this.animate();
      }
      _setupUI() {
        const blocker = document.getElementById('blocker'), instructions = document.getElementById('instructions'), crosshair = document.getElementById('crosshair');
        instructions.addEventListener('click', () => this.player.controls.lock());
        this.player.controls.addEventListener('lock', () => { instructions.style.display = 'none'; blocker.style.display = 'none'; crosshair.style.display = 'block'; });
        this.player.controls.addEventListener('unlock', () => { blocker.style.display = 'flex'; instructions.style.display = 'block'; crosshair.style.display = 'none'; });
      }
      onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }
      animate() {
        requestAnimationFrame(() => this.animate());
        const delta = this.clock.getDelta();
        const time = this.clock.getElapsedTime();
        this.physics.update(delta);
        this.enemyManager.update(delta, this.player.body.position);

        // [수정] update에 ladderData 전달
        this.player.update(delta, time, this.level.meshes, this.enemyManager.getMeshList(), this.level.ladders);

        this.renderer.render(this.scene, this.camera);
      }
    }
    new Game();
  </script>
</body>

</html>